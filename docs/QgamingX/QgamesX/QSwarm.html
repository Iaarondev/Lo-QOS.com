<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Swarm Commander</title>
    <style>
        :root {
            --quantum-primary: #00ffff;
            --quantum-secondary: #6a0dad;
            --background-dark: #121212;
            --text-light: #ffffff;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: var(--background-dark);
            color: var(--text-light);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }

        #gameCanvas {
            border: 2px solid var(--quantum-primary);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .game-ui {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px;
            margin: 10px 0;
        }

        .stat-panel {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .button {
            background-color: var(--quantum-primary);
            color: var(--background-dark);
            border: none;
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .button:hover {
            background-color: var(--quantum-secondary);
            transform: scale(1.05);
        }

        #quantumStateDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 5px;
        }

        #gameOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #gameOverlay.active {
            display: flex;
        }
    </style>
</head>
<body>
    <div id="quantumStateDisplay">Quantum State: 0.0</div>
    <canvas id="gameCanvas"></canvas>
    <div class="game-ui">
        <div class="stat-panel">
            <h3>Swarm Units</h3>
            <p id="unitCountDisplay">0</p>
        </div>
        <div class="stat-panel">
            <h3>Resource Points</h3>
            <p id="resourcePointsDisplay">1000</p>
        </div>
        <div class="stat-panel">
            <h3>Performance</h3>
            <p id="performanceDisplay">100%</p>
        </div>
    </div>
    <div>
        <button class="button" id="spawnUnitBtn">Spawn Unit</button>
        <button class="button" id="formationBtn">Change Formation</button>
    </div>

    <div id="gameOverlay">
        <h2 id="gameOverTitle">Game Over</h2>
        <p id="gameOverMessage">Your quantum swarm has been depleted.</p>
        <button class="button" id="restartBtn">Restart Game</button>
    </div>

    <script>
        class QuantumSwarmCommander {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.units = [];
                this.quantumState = 0;
                this.resourcePoints = 1000;
                this.performanceLevel = 100;
                this.entanglementMap = new Map();
                this.maxUnits = 50; // Limit total units
                this.enemySwarm = []; // Enemy units to add challenge
                this.isGameOver = false;

                this.formations = [
                    this.circleFormation,
                    this.hexFormation,
                    this.spiralFormation,
                    this.fracturedFormation
                ];
                this.currentFormationIndex = 0;

                // Initialize some enemy units
                this.initializeEnemySwarm();
            }

            // Initialize enemy swarm
            initializeEnemySwarm() {
                for (let i = 0; i < 10; i++) {
                    this.enemySwarm.push({
                        position: {
                            x: Math.random() * this.canvas.width,
                            y: Math.random() * this.canvas.height
                        },
                        velocity: {
                            x: (Math.random() - 0.5) * 3,
                            y: (Math.random() - 0.5) * 3
                        },
                        size: Math.random() * 15 + 10,
                        color: 'rgba(255, 0, 0, 0.7)'
                    });
                }
            }

            // Rest of the previous implementation remains the same...
            
            // New method to detect collisions
            checkCollisions() {
                // Check collisions between player units and enemy units
                for (let playerUnit of this.units) {
                    for (let enemyUnit of this.enemySwarm) {
                        const dx = playerUnit.position.x - enemyUnit.position.x;
                        const dy = playerUnit.position.y - enemyUnit.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // Collision detection
                        if (distance < (playerUnit.size + enemyUnit.size)) {
                            // Reduce unit size or remove unit
                            playerUnit.size *= 0.9;
                            
                            // If unit becomes too small, remove it
                            if (playerUnit.size < 1) {
                                this.units = this.units.filter(u => u !== playerUnit);
                            }
                        }
                    }
                }

                // Check if all units are destroyed
                if (this.units.length === 0) {
                    this.gameOver();
                }
            }

            // Game over method
            gameOver() {
                this.isGameOver = true;
                document.getElementById('gameOverlay').classList.add('active');
            }

            // Restart game method
            restart() {
                // Reset all game state
                this.units = [];
                this.quantumState = 0;
                this.resourcePoints = 1000;
                this.performanceLevel = 100;
                this.entanglementMap.clear();
                this.enemySwarm = [];
                this.isGameOver = false;

                // Reinitialize enemy swarm
                this.initializeEnemySwarm();

                // Hide game over overlay
                document.getElementById('gameOverlay').classList.remove('active');
            }

            // Update enemy movement
            updateEnemies() {
                this.enemySwarm.forEach(enemy => {
                    // Simple movement logic for enemies
                    enemy.position.x += enemy.velocity.x;
                    enemy.position.y += enemy.velocity.y;

                    // Wrap around canvas
                    enemy.position.x = (enemy.position.x + this.canvas.width) % this.canvas.width;
                    enemy.position.y = (enemy.position.y + this.canvas.height) % this.canvas.height;

                    // Slight random velocity changes
                    enemy.velocity.x += (Math.random() - 0.5) * 0.2;
                    enemy.velocity.y += (Math.random() - 0.5) * 0.2;

                    // Limit velocity
                    const speed = Math.sqrt(
                        enemy.velocity.x * enemy.velocity.x + 
                        enemy.velocity.y * enemy.velocity.y
                    );
                    if (speed > 3) {
                        enemy.velocity.x *= 3 / speed;
                        enemy.velocity.y *= 3 / speed;
                    }
                });
            }

            // Render enemies
            renderEnemies() {
                this.enemySwarm.forEach(enemy => {
                    this.ctx.beginPath();
                    this.ctx.fillStyle = enemy.color;
                    this.ctx.arc(
                        enemy.position.x, 
                        enemy.position.y, 
                        enemy.size, 
                        0, 
                        Math.PI * 2
                    );
                    this.ctx.fill();
                });
            }

            // Override update method to include enemy updates and collision checks
            update() {
                // Prevent updates if game is over
                if (this.isGameOver) return;

                // Progress quantum state
                this.quantumState = (this.quantumState + 0.01) % 1;

                // Update enemy units
                this.updateEnemies();

                // Recreate entanglement map periodically
                if (Math.random() < 0.05) {
                    this.createEntanglementMap();
                }

                // Update units
                this.units.forEach(unit => {
                    // Optimize movement through entanglement
                    this.optimizeUnitMovement(unit);

                    // Update position
                    unit.position.x += unit.velocity.x;
                    unit.position.y += unit.velocity.y;

                    // Wrap around canvas
                    unit.position.x = (unit.position.x + this.canvas.width) % this.canvas.width;
                    unit.position.y = (unit.position.y + this.canvas.height) % this.canvas.height;
                });

                // Check for collisions
                this.checkCollisions();

                // Dynamically adjust performance
                this.updatePerformance();
            }

            // Override render to include enemy rendering
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Render entanglement connections
                this.units.forEach(unit => {
                    if (unit.entangledUnits) {
                        unit.entangledUnits.forEach(connection => {
                            this.ctx.beginPath();
                            this.ctx.strokeStyle = `rgba(0, 255, 255, ${connection.strength * 0.5})`;
                            this.ctx.moveTo(unit.position.x, unit.position.y);
                            this.ctx.lineTo(
                                connection.unit.position.x, 
                                connection.unit.position.y
                            );
                            this.ctx.stroke();
                        });
                    }
                });

                // Render units
                this.units.forEach(unit => {
                    this.ctx.beginPath();
                    this.ctx.fillStyle = unit.color;
                    this.ctx.arc(
                        unit.position.x, 
                        unit.position.y, 
                        unit.size, 
                        0, 
                        Math.PI * 2
                    );
                    this.ctx.fill();
                });

                // Render enemies
                this.renderEnemies();
            }

            // Spawn a new unit (modified to respect max units)
            spawnUnit() {
                if (this.units.length >= this.maxUnits) return;
                if (this.resourcePoints < 10) return;

                const unit = {
                    position: {
                        x: this.canvas.width / 2,
                        y: this.canvas.height / 2
                    },
                    velocity: {
                        x: (Math.random() - 0.5) * 2,
                        y: (Math.random() - 0.5) * 2
                    },
                    size: Math.random() * 10 + 5,
                    color: this.generateQuantumColor(),
                    entangledUnits: []
                };

                this.units.push(unit);
                this.resourcePoints -= 10;
                this.resourcePoints += Math.floor(this.quantumState * 5);
            }

            // Rest of the previous methods remain the same...
        }

        // Game Setup
        const canvas = document.getElementById('gameCanvas');
        const unitCountDisplay = document.getElementById('unitCountDisplay');
        const resourcePointsDisplay = document.getElementById('resourcePointsDisplay');
        const performanceDisplay = document.getElementById('performanceDisplay');
        const quantumStateDisplay = document.getElementById('quantumStateDisplay');
        const spawnUnitBtn = document.getElementById('spawnUnitBtn');
        const formationBtn = document.getElementById('formationBtn');
        const restartBtn = document.getElementById('restartBtn');

        function resizeCanvas() {
            canvas.width = window.innerWidth * 0.95;
            canvas.height = window.innerHeight * 0.8;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const game = new QuantumSwarmCommander(canvas);

        // Game Loop
        function gameLoop() {
            game.update();
            game.render();

            // Update UI
            unitCountDisplay.textContent = game.units.length;
            resourcePointsDisplay.textContent = Math.floor(game.resourcePoints);
            performanceDisplay.textContent = `${game.performanceLevel.toFixed(2)}%`;
            quantumStateDisplay.textContent = `Quantum State: ${game.quantumState.toFixed(2)}`;

            requestAnimationFrame(gameLoop);
        }

        // Event Listeners
        spawnUnitBtn.addEventListener('click', () => game.spawnUnit());
        formationBtn.addEventListener('click', () => game.changeFormation());
        restartBtn.addEventListener('click', () => game.restart());

        // Start Game Loop
        gameLoop();
    </script>
</body>
</html>