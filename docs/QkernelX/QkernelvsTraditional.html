<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Q-Kernel vs. Traditional Kernel: Subsystem Entanglement Map</title>
    <meta name="description" content="Explore the conceptual differences between a traditional operating system kernel and a hypothetical Q-Kernel leveraging quantum computing principles, the Swarm Oracle Network, and multi-agent systems.  This interactive diagram visualizes subsystem dependencies and entanglement, showcasing potential quantum enhancements.">
    <meta name="keywords" content="Q-Kernel, quantum computing, operating system, kernel, scheduler, memory manager, IPC, security, interrupts, entanglement, superposition, quantum algorithms, traditional kernel, subsystem, dependency map, visualization, Swarm Oracle Network, multi-agent system, optimization, Coinbase, oracle, AI, glassmorphism, quantum">
    <meta name="robots" content="index, follow">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e); /* Dark, quantum-inspired background */
            color: #fff;
        }

        #container {
            background-color: rgba(255, 255, 255, 0.1); /* Glassmorphism - translucent white */
            backdrop-filter: blur(10px); /* Glassmorphism - blur effect */
            border-radius: 15px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); /* Glassmorphism - subtle shadow */
            border: 1px solid rgba(255, 255, 255, 0.18); /* Glassmorphism - subtle border */
            padding: 20px;
            overflow: auto;
            margin-bottom: 20px;
            width: 95%; /* Responsive width */
            max-width: 1400px; /* Limit maximum width */
        }
        #description {
          background-color: rgba(255, 255, 255, 0.1);
          backdrop-filter: blur(10px);
          border-radius: 15px;
          box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
          border: 1px solid rgba(255, 255, 255, 0.18);
          padding: 20px;
          width: 90%;
          max-width: 1300px;
          text-align: left;
          margin-top: 1em;
          color: #eee;
        }

        #svg-container {
            display: flex;
            justify-content: space-around;
            width: 100%;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        #kernel-map-svg-traditional, #kernel-map-svg-qkernel {
            width: 48%; /* Adjust width as needed */
            min-width: 300px; /* Minimum width for smaller screens */
            height: auto; /* Maintain aspect ratio */
            margin-bottom: 20px;
        }


    /* Node Styles */
    .node {
      stroke: #fff;
      stroke-width: 1.5px;
      cursor: pointer;
      transition: all 0.3s ease; /* Smooth transitions */
      fill: rgba(255, 255, 255, 0.2); /* Semi-transparent */
    }

    .node:hover {
        stroke: #66ccff; /* Brighter stroke on hover */
        stroke-width: 2.5px;
        transform: scale(1.1); /* Slightly enlarge on hover */
    }

    /* Link Styles */
      .link {
        stroke-width: 2px;
        stroke-opacity: 0.7; /* Slightly more opaque */
        transition: stroke-opacity 0.2s ease, stroke-width 0.2s ease, stroke 0.3s ease; /* Smooth transition */
      }

      .strong-link {
      stroke-width: 4;
        stroke: #228B22; /* Forest Green */
        animation: pulse-strong 2s infinite; /* Gentle pulse animation */
      }

      .medium-link {
        stroke-width: 2.5;
        stroke: #3CB371; /* Medium Sea Green */
        animation: pulse-medium 3s infinite; /* Slower pulse */
      }

      .weak-link {
        stroke-dasharray: 5, 5;
        stroke: #90EE90; /* Light Green */
        animation: pulse-weak 5s infinite;  /* Even Slower Pulse*/
      }

    /* Label Styles */
    .label {
        font-family: 'Roboto', sans-serif; /* Modern font */
        font-size: 14px;
        pointer-events: none;
        text-anchor: middle;
        dominant-baseline: text-after-edge;
        fill: #eee; /* Light text color */
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); /* Subtle text shadow */
    }

    .q-label {
        dominant-baseline: text-before-edge;
        font-weight: bold;
        font-size: 16px;
    }
    .traditional-label {
        font-style: italic;
    }


     /* Tooltip Styles */
    .tooltip {
      visibility: hidden;
      position: absolute;
      background-color: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 8px; /* More padding */
      border-radius: 8px; /* Rounded corners */
      font-size: 12px;
      pointer-events: none;
      white-space: pre-line;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Add a shadow */
      z-index: 10; /* Ensure it's on top */
    }

    /* Highlight Styles */
    .highlighted-link {
        stroke: #00bfff; /* Bright blue for highlighting */
        stroke-width: 4px; /* Thicker line */
        stroke-opacity: 1;
    }

    .highlighted-node {
        fill: rgba(0, 191, 255, 0.6); /* Semi-transparent blue */
        stroke: #0056b3;
        stroke-width: 3px;
        transform: scale(1.2); /* Slightly larger */
        z-index: 5; /* Bring to front */
    }



    .kernel-title {
        font-size: 22px; /* Larger title */
        font-weight: bold;
        text-anchor: middle;
        dominant-baseline: hanging;
        margin-bottom: 20px;
    }
      .legend-label {
        font-size: 18px; /* Larger legend labels */
        font-weight: bold;
        text-anchor: start;
        margin-bottom: 10px;
    }

    /* Specific Styles for Kernels */
    .traditional-node {
        fill: rgba(70, 130, 180, 0.4); /* Steel Blue - Semi-transparent */
        stroke: #4682B4; /* Steel Blue */
    }

    .q-node {
         fill: rgba(50, 205, 50, 0.4); /* Lime Green - Semi-transparent */
        stroke: #32CD32; /* Lime Green */
    }

    /* Animations */
    @keyframes pulse-strong {
      0% { stroke-width: 4; stroke-opacity: 0.7; }
      50% { stroke-width: 5; stroke-opacity: 1; }
      100% { stroke-width: 4; stroke-opacity: 0.7; }
    }
    @keyframes pulse-medium {
      0% { stroke-width: 2.5; stroke-opacity: 0.7; }
      50% { stroke-width: 3; stroke-opacity: 0.9; }
      100% { stroke-width: 2.5; stroke-opacity: 0.7; }
    }

        @keyframes pulse-weak {
      0% { stroke-width: 2; stroke-opacity: 0.5; }
      50% { stroke-width: 2.5; stroke-opacity: 0.7; }
      100% { stroke-width: 2; stroke-opacity: 0.5; }
    }

    /* Responsive adjustments */
      @media (max-width: 800px) {
        #svg-container {
          flex-direction: column; /* Stack SVGs vertically */
        }
        #kernel-map-svg-traditional, #kernel-map-svg-qkernel {
            width: 95%;
        }
    }

    /* Legend Key Item Styles */
    .legend-key {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .legend-color-box {
      width: 20px;
      height: 20px;
      border: 1px solid #ccc;
      margin-right: 10px;
    }
       /* Hide tooltips by default on mobile */
    @media (max-width: 600px) {
        .tooltip {
            display: none !important;
        }
         #description, #container{
           width: 98%;
         }
    }


    </style>
</head>
<body>
    <div id="container">
      <div id="svg-container">
        <!-- Traditional Kernel SVG -->
        <svg id="kernel-map-svg-traditional" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
          <text x="50%" y="30" class="kernel-title">Traditional Kernel</text>
            <g id="links-traditional"></g>
            <g id="nodes-traditional"></g>
            <rect id="tooltip-bg-traditional" class="tooltip" x="0" y="0" width="120" height="40" rx="5" ry="5"/>
            <text id="tooltip-text-traditional" class="tooltip" x="10" y="20"></text>
        </svg>

        <!-- Separator Line (moved outside SVGs) -->
        <div style="width: 1px; height: 80%; background-color: rgba(255, 255, 255, 0.2); margin: 0 10px;"></div>

        <!-- Q-Kernel SVG -->
         <svg id="kernel-map-svg-qkernel" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
          <text x="50%" y="30" class="kernel-title">Q-Kernel</text>
          <g id="links-qkernel"></g>
          <g id="nodes-qkernel"></g>
          <rect id="tooltip-bg-qkernel" class="tooltip" x="0" y="0" width="120" height="50" rx="5" ry="5"/>
          <text id="tooltip-text-qkernel" class="tooltip" x="10" y="20"></text>
        </svg>
      </div>
        <!-- Legend (Moved outside of SVG) -->
        <div style="width: 300px; margin: 20px auto 0;">
            <h3 class="legend-label">Legend</h3>
            <div class="legend-key">
                <div class="legend-color-box traditional-node"></div>
                <span>Traditional Kernel Node</span>
            </div>
            <div class="legend-key">
                <div class="legend-color-box q-node"> </div>
                <span>Q-Kernel Node</span>
            </div>
             <div class="legend-key">
                <div style="width: 20px; height: 3px; background-color: #228B22;"></div>
                <span>Strong Dependency</span>
            </div>
            <div class="legend-key">
                <div style="width: 20px; height: 3px; background-color: #3CB371;"></div>
                <span>Medium Dependency</span>
            </div>
             <div class="legend-key">
                   <div style="width: 20px; height: 3px; background-color:#90EE90; border: 1px dashed #90EE90;"></div>
                <span>Weak Dependency</span>
            </div>
        </div>

    </div>


    <div id="description">
      <h2>Q-Kernel vs. Traditional Kernel: Subsystem Entanglement Visualization</h2>
      <p>
          This interactive diagram presents a comparative visualization of subsystem relationships within a <strong>traditional operating system kernel</strong> and a conceptual <strong>Q-Kernel</strong>. The Q-Kernel leverages principles of quantum computing, the <a href="https://www.coinbase.com/price/swarm-network" target="_blank">Swarm Oracle Network</a>, and multi-agent system design for enhanced optimization and coordination.
      </p>
      <h3>Traditional Kernel</h3>
      <p>
          Represents a standard monolithic or microkernel architecture.  Nodes (circles) depict core subsystems, and lines indicate dependencies.  Traditional kernels often exhibit a hierarchical structure, with subsystems designed and optimized in relative isolation. This can lead to performance bottlenecks and inefficiencies when managing complex, dynamic workloads.
      </p>

      <h3>Q-Kernel</h3>
      <p>
           The Q-Kernel, represented on the right, introduces a novel approach inspired by quantum mechanics.  Key concepts include:
      </p>
      <ul>
        <li><strong>Entanglement-Inspired Subsystem Management:</strong>  Subsystems are treated as "entangled" entities. Changes in one subsystem can instantly influence others, facilitating system-wide optimization strategies. This is a conceptual analogy, not a literal implementation of quantum entanglement.</li>
        <li><strong>Swarm Oracle Network Integration:</strong>  A decentralized network of oracles (inspired by Coinbase's Swarm) provides real-time, verified data about system state, resource availability, and external conditions.  This data feeds into the Q-Kernel's optimization algorithms.</li>
        <li><strong>Multi-Agent System Coordination:</strong>  Kernel subsystems are managed by interacting software agents.  These agents utilize game theory, reinforcement learning,  and distributed consensus mechanisms to achieve coordinated optimization goals.</li>
        <li><strong>Qubit-to-Bit Assembly (QBA):</strong>  A conceptual mechanism for mapping quantum computational results (from simulations or hybrid computations) to classical bit-level instructions for kernel operations. This allows for leveraging quantum algorithms for specific optimization tasks.</li>
        <li><strong>Golden Ratio Optimization:</strong> Incorporates the golden ratio (φ ≈ 1.618) into scheduling and resource allocation algorithms to achieve a balance between efficiency and fairness, drawing inspiration from its prevalence in natural systems.</li>
      </ul>

        <h3>Interactive Features</h3>
        <ul>
          <li><strong>Click:</strong> Select a node to highlight its immediate dependencies.</li>
          <li><strong>Hover:</strong> View a tooltip with detailed information about the selected subsystem and its role in the kernel.</li>
          <li><strong>Line Thickness/Style:</strong> Represents the strength of the relationship between subsystems:
        <ul><span>•  <b>Strong</b>: Direct, frequent interaction and high interdependence.</span>
            <span>• <b>Medium</b>: Significant interaction, but with some degree of independence.</span>
          <span>•  <b>Weak</b>:  Infrequent interaction or indirect dependencies, often through shared resources.</span>
        </ul>
      </li>
        </ul>

      <h3>Subsystem Details</h3>
      <p>
        Hover over a node for specific descriptions. The Q-Kernel subsystems include:
      </p>
           <ul>
                <li><strong>Scheduler (Q-Kernel):</strong>  Advanced scheduling using Golden Ratio optimization and real-time data from the Swarm Oracle Network.  Dynamic prioritization and workload balancing.</li>
                <li><strong>Memory Manager (Q-Kernel):</strong> Incorporates QBA for optimal memory allocation, preventing leaks and enhancing efficiency.  Responds to system-wide demands in coordinated fashion.</li>
                <li><strong>Inter-Process Communication (IPC)(Q-Kernel):</strong>  Leverages quantum-inspired algorithms for fast, secure, and ultra-low latency communication between processes, informed by multi-agent negotiation.</li>
                <li><strong>Security Module (Q-Kernel):</strong> Utilizes quantum-resistant cryptography and distributed consensus mechanisms for robust security and integrity verification. Key distribution and threat detection via the Swarm network.</li>
                <li><strong>Interrupt Handler (Q-Kernel):</strong>  Quantum-prioritized interrupt handling.  Predictive preemption based on system-wide analysis.</li>
                <li><strong>File System (Q-Kernel)</strong>: Optimized through agent-based negotiation and system-wide state awareness</li>
            </ul>


      <h3>Disclaimer</h3>
      <p>
          The Q-Kernel architecture presented here is a highly speculative, future-oriented concept.  Many of the proposed quantum enhancements rely on advancements in quantum computing and distributed systems that are currently under research.  The visualization is intended to illustrate potential future directions, rather than an immediately implementable design.
      </p>
</div>
    <script>
   // Data for Traditional Kernel
   const traditionalData = {
      nodes: [
        { id: "traditional-scheduler", name: "Scheduler", x: 100, y: 100 , details: "Traditional scheduler, often priority-based or round-robin.  Operates largely independently, less adaptable to dynamic workloads.", class:"traditional-node" },
        { id: "traditional-memory_manager", name: "Memory Manager", x: 300, y: 100, details: "Standard memory management techniques. May not optimize for global system efficiency, focuses on local process needs.",class:"traditional-node" },
        { id: "traditional-filesystem", name: "File System", x: 100, y: 250 , details: "Traditional file system (e.g., ext4, NTFS).  Focuses on individual file operations, minimal interaction with other subsystems.", class:"traditional-node"},
        { id: "traditional-network_stack", name: "Network Stack", x: 300, y: 250 , details: "Standard network stack. Protocol-specific optimizations.  Limited interaction with other subsystems outside of direct data transfer.", class:"traditional-node" },
        { id: "traditional-device_drivers", name: "Device Drivers", x: 200, y: 400, details: "Drivers for hardware devices.  Typically operate independently, responding to hardware interrupts.",class:"traditional-node" },
      ],
      links: [
        { source: "traditional-scheduler", target: "traditional-memory_manager", type:"medium" },
        { source: "traditional-memory_manager", target: "traditional-filesystem", type:"medium" },
        { source: "traditional-filesystem", target: "traditional-device_drivers",type:"medium" },
        { source: "traditional-network_stack", target: "traditional-device_drivers", type:"medium"},
      ]
    };


      // Data for Q-Kernel (Enhanced with more details and Swarm integration)
        const qData = {
          nodes: [
            { id: "q-scheduler", name: "Scheduler", x: 100, y: 100, details: "Advanced scheduling using Golden Ratio optimization and real-time data from the Swarm Oracle Network.\nDynamic prioritization of tasks based on global system state.  Agent-based workload balancing.", class: "q-node" },
            { id: "q-memory_manager", name: "Memory Manager", x: 300, y: 100, details: "Incorporates QBA for optimal memory allocation, garbage collection, and protection.\nResponds to system-wide memory demands, coordinated via multi-agent negotiation.\nLeverages Swarm oracles for real-time memory pressure data.", class: "q-node" },
            { id: "q-ipc", name: "IPC", x: 100, y: 250, details: "Inter-Process Communication (IPC) using quantum-inspired algorithms for fast, secure, and ultra-low latency.\nMulti-agent negotiation for optimized data transfer routes and priorities.\nEntanglement-inspired approach for synchronized communication across processes.", class: "q-node" },
            { id: "q-security_module", name: "Security Module", x: 300, y: 250, details: "Employs quantum-resistant cryptography and distributed consensus mechanisms for enhanced security.\nKey distribution and threat detection using the Swarm Oracle Network.\nMulti-agent system monitors for anomalies and coordinates responses.", class: "q-node" },
            { id: "q-interrupt_handler", name: "Interrupt Handler", x: 50, y: 400, details: "Quantum-prioritized interrupt handling, minimizing latency for critical operations.\nPredictive preemption based on system-wide analysis, informed by Swarm data.\nAdaptive response based on multi-agent consensus.", class: "q-node" },
            { id: "q-device_drivers", name: "Device Drivers", x: 200, y: 400, details: "Device driver management optimized through a multi-agent system.\nReal-time adaptation to device states using Swarm Oracle data.\nCoordinated resource allocation via agent negotiation.", class: "q-node" },
            { id: "q-network_stack",   name: "Network Stack",    x: 350, y: 400 , details: "Network stack leverages QBA for optimal packet routing. Multi-agent negotiation for network load balancing.", class:"q-node"},
            {id: "q-filesystem", name:"File System", x: 500, y:250, details: "File system optimized by Swarm Network data on file access and access control.", class: "q-node"}
         ],
          links: [
            { source: "q-scheduler", target: "q-memory_manager", type: "strong" },
            { source: "q-scheduler", target: "q-ipc", type: "strong" },
            { source: "q-scheduler", target: "q-interrupt_handler", type: "strong" },
            { source: "q-memory_manager", target: "q-ipc", type: "medium" },
             { source: "q-memory_manager", target: "q-security_module", type: "medium" },
            { source: "q-memory_manager", target: "q-filesystem", type:"medium"},
            { source: "q-ipc", target: "q-security_module", type: "medium" },
            { source: "q-security_module", target: "q-device_drivers", type: "weak" },
            { source: "q-security_module", target: "q-network_stack", type: "weak" },
            { source: "q-interrupt_handler", target: "q-device_drivers", type: "medium" },
             {source: "q-device_drivers", target: "q-network_stack", type:"medium"},
             {source: "q-filesystem", target: "q-security_module", type:"weak"},
             {source:"q-filesystem", target: "q-memory_manager", type: "medium"}
          ]
        };


    // Get SVG elements (Corrected IDs)
     const traditionalLinksGroup = document.getElementById("links-traditional");
     const traditionalNodesGroup = document.getElementById("nodes-traditional");
     const qLinksGroup = document.getElementById("links-qkernel"); // Corrected ID
     const qNodesGroup = document.getElementById("nodes-qkernel"); // Corrected ID

        // Function to create links (Generalized)
        function createLinks(data, linksGroup) {
          data.links.forEach(link => {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            const sourceNode = data.nodes.find(n => n.id === link.source);
            const targetNode = data.nodes.find(n => n.id === link.target);

            // Check if sourceNode and targetNode exist, handle missing
            if (!sourceNode || !targetNode) {
              console.warn(`Missing node for link: ${link.source} -> ${link.target}`);
              return; // Skip this link
            }
            line.setAttribute("x1", sourceNode.x);
            line.setAttribute("y1", sourceNode.y);
            line.setAttribute("x2", targetNode.x);
            line.setAttribute("y2", targetNode.y);
            line.setAttribute("class", `link ${link.type}-link`);
            line.dataset.source = link.source.replace(/^traditional-|^q-/, ''); // Store the source ID
            line.dataset.target = link.target.replace(/^traditional-|^q-/, ''); // Store the target ID
            linksGroup.appendChild(line);
          });
        }

       // Function to create nodes (Generalized - for BOTH kernels)
       function createNodes(data, nodesGroup) {
          const isQKernel = nodesGroup.id.startsWith("nodes-q"); // Check if it's Q-Kernel nodes

            data.nodes.forEach(node => {
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", node.x);
            circle.setAttribute("cy", node.y);
            circle.setAttribute("r", 20);
            circle.setAttribute("class", `node ${node.class}`); // Use class from data
            circle.setAttribute("id", node.id); // Keep the ID as is (prefixed for traditional)
            circle.addEventListener("click", () => highlightNode(node.id));
            circle.addEventListener("mouseover", (event) => showTooltip(event, node, isQKernel));
            circle.addEventListener("mouseout", () => hideTooltip(isQKernel));
            nodesGroup.appendChild(circle);

            const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
            label.setAttribute("class", isQKernel ? "label q-label" : "label traditional-label");
            label.setAttribute("x", node.x);
            label.setAttribute("y", isQKernel ? node.y - 25 : node.y + 25); // Position above if Q-Kernel
            label.textContent = node.name;
            nodesGroup.appendChild(label);
          });
        }



        function highlightNode(nodeId) {
              // Determine if it's a traditional or Q-Kernel node
            const isQKernel = !nodeId.startsWith("traditional-");
            const nodesGroup = isQKernel ? qNodesGroup : traditionalNodesGroup;
            const linksGroup = isQKernel ? qLinksGroup : traditionalLinksGroup;

            resetHighlight(); // First, reset any previous highlights

             // Highlight the clicked node
            const clickedNode = document.getElementById(nodeId); // Use the full ID

            if (clickedNode) {
                 clickedNode.classList.add("highlighted-node");
            }
           // Highlight links and connected nodes for Q-Kernel;
           if (isQKernel){
                const allLinks = Array.from(linksGroup.getElementsByClassName("link"));
                allLinks.forEach(link => {
                if (link.dataset.source === nodeId.replace(/^q-/, '') || link.dataset.target === nodeId.replace(/^q-/, '')) {
                link.classList.add("highlighted-link");

                    //highlight target
                    const targetNode = document.getElementById("q-" + link.dataset.target);
                    if(targetNode){
                        targetNode.classList.add("highlighted-node")
                    }

                    //highlight source
                    const sourceNode = document.getElementById("q-" + link.dataset.source);
                    if(sourceNode){
                        sourceNode.classList.add("highlighted-node");
                    }

                  }
              });
           }
           //Highlight links and connected nodes for Traditional Kernel
          else{
               const allLinks = Array.from(linksGroup.getElementsByClassName("link"));
                allLinks.forEach(link => {
                if (link.dataset.source === nodeId.replace(/^traditional-/, '') || link.dataset.target === nodeId.replace(/^traditional-/, '')) {

                link.classList.add("highlighted-link");
                    //highlight target
                    const targetNode = document.getElementById("traditional-" + link.dataset.target);
                    if(targetNode){
                        targetNode.classList.add("highlighted-node")
                    }

                    //highlight source
                    const sourceNode = document.getElementById("traditional-" + link.dataset.source);
                    if(sourceNode){
                        sourceNode.classList.add("highlighted-node");
                    }

                  }
              });
           }

        }

      function resetHighlight() {
            // Reset traditional nodes and links
          const traditionalNodes = Array.from(traditionalNodesGroup.getElementsByClassName("node"));
          traditionalNodes.forEach(node => node.classList.remove("highlighted-node"));

          const traditionalLinks = Array.from(traditionalLinksGroup.getElementsByClassName("link"));
          traditionalLinks.forEach(link => link.classList.remove("highlighted-link"));

          // Reset Q-Kernel nodes and links
          const qNodes = Array.from(qNodesGroup.getElementsByClassName("node"));
          qNodes.forEach(node => node.classList.remove("highlighted-node"));

          const qLinks = Array.from(qLinksGroup.getElementsByClassName("link"));
          qLinks.forEach(link => link.classList.remove("highlighted-link"));
      }


       function showTooltip(event, node, isQKernel) {
            const tooltipText = isQKernel ? document.getElementById("tooltip-text-qkernel") : document.getElementById("tooltip-text-traditional");
            const tooltipBg = isQKernel ? document.getElementById("tooltip-bg-qkernel") : document.getElementById("tooltip-bg-traditional");


            tooltipText.textContent = `${node.name}: ${node.details}`;

            const textWidth = tooltipText.getComputedTextLength(); // Get *actual* text width, crucial for correct sizing.  This method works even with hidden temporary element.

            tooltipBg.setAttribute("width", textWidth + 20);
            tooltipBg.setAttribute("height", 60); // Adjust as necessary


            tooltipText.setAttribute("visibility", "visible");
            tooltipBg.setAttribute("visibility", "visible");

            // Position the tooltip.  Adjust as needed for your layout.
          const x = event.clientX + 15; // Offset from cursor.
          const y = event.clientY + 15;
          tooltipBg.setAttribute("x", x);
          tooltipBg.setAttribute("y", y);
          tooltipText.setAttribute("x", x+10);
          tooltipText.setAttribute("y", y + 15);
        }

        function hideTooltip(isQKernel) {
          const tooltipText = isQKernel ? document.getElementById("tooltip-text-qkernel") : document.getElementById("tooltip-text-traditional");
          const tooltipBg = isQKernel ? document.getElementById("tooltip-bg-qkernel") : document.getElementById("tooltip-bg-traditional");
          tooltipText.setAttribute("visibility", "hidden");
          tooltipBg.setAttribute("visibility", "hidden");
       }


    // Initialize
    createLinks(traditionalData, traditionalLinksGroup);
    createNodes(traditionalData, traditionalNodesGroup);
    createLinks(qData, qLinksGroup);
    createNodes(qData, qNodesGroup);

    //Reset when clicking in an empty space
     document.addEventListener("click", (event) => {
        if (!event.target.classList.contains("node")) {
          resetHighlight();
        }
      }, true); // Use capture phase to intercept clicks before they reach the node

    </script>
</body>
</html>
